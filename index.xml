<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>细胞的作战实验室</title>
    <link>http://azen.me/</link>
    <description>Recent content on 细胞的作战实验室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://azen.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang与密码学</title>
      <link>http://azen.me/code/golang%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/golang%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/</guid>
      <description>&amp;nbsp;
0x0 概述这篇文档主要聊聊三种加密方式与Golang实现
哈希加密对称加密非对称加密0x1 哈希加密哈希算法我们知道，查找中，有「哈希查找」，是一种比「顺序查找」更快的查找方法。
「哈希查找」的关键点，就是实现一种「哈希算法」，使得每个任意key，经过哈希算法计算后，可以获得一个定长的散列值。
相同key经过相同哈希算法散列之后，获得相同的散列值不同key经过相同哈西算法散列之后，获得不同的散列值特点：
可以把任意长度的「明文」，散列成固定长度的「指纹」正向计算简单快速，逆向推算困难，基本不可能逆推出明文明文有一点点变化，密文就会改变优秀的散列算法需要尽量避免两个不同的明文，加密出来是相同的指纹发展：
 取模操作 → 异或运算→ 位移操作
密码学里面，一般都通过「位移操作」「取模操作」「异或操作」来实现加密 - 无论对称加密非对称加密、哈希散列加密
成熟Hash算法MD5SHARIPEMDGolang相关hash代码片段MD5MD5加密结果为16字节串
data := []byte(&#34;test string&#34;) s := fmt.Sprintf(&#34;%x&#34;, md5.Sum(data))m := md5.New() m.Write(content) s := hex.EncodeToString(m.Sum(nil))SHA256sha256加密方式，通常用在公链中，散列结果为32字节
s := fmt.Sprintf(&#34;%x&#34;, sha256.Sum256(content))m := sha256.New() m.Write(content) fmt.Println(hex.EncodeToString(m.Sum(nil)))文件内容加密
f,_ := os.Open(&#34;filename&#34;) h := sha256.New() io.Copy(h,f) s := h.Sum(nil) fmt.Println(hex.EncodeToString(s))RIPEMD160ripemd160目前只在数字货币中用到了 - 以太坊
三方包：golang.org/x/crypto/ripemd160
可以使用gopm安装
gopm get -v -u golang.org/x/crypto/ripemd160
hasher := ripemd160.New() hasher.Write([]byte(&#34;test string&#34;)) fmt.Println(hex.EncodeToString(hasher.Sum(nil)))0x2 对称加密对称加密，加密完之后，是可以通过密钥解密的 - 和hash加密不一样
常见对称加密算法：
DESAES补码、去码 &amp;amp; 分组加密补码：给15个字符做「分组加密」，无法平均分成两组，所以需要补一个码凑成16个字符，这种操作叫做「补码」</description>
    </item>
    
    <item>
      <title>产品相关技能树</title>
      <link>http://azen.me/code/product-routine/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/product-routine/</guid>
      <description>&amp;nbsp;
PM技能树从起点学院 - 产品经理就业班 扒过来的，可以通过相关模块自我诊断 &amp;amp; 查缺补漏
学习某个领域知识，最根本的点就是在于拿到一份「地图」
需求阶段学习阶段 
课程章节 
详细内容 
课程目的 
Step01 
解构产品经理 
1) 互联网行业发展史简述
2) 什么是产品?产品的常见分类(基于案例)? 
3) 产品从0到1到99是怎么产生的? 
4) 什么是产品经理?产品经理的基本职责和工作流程 
5) 产品经理的能力要求 
6) 给新入行产品经理的学习建议 
7) 图解互联网公司的几大核心岗位 
了解互联网行业基本概况理解产品经理的岗位工作和价值所在了解产品从0 到1的全流程对产品认知：产品是解决用户需求问题明确各项能力要求及目的意义Step02 
市场分析 
1) 案例剖析:产品成败的因素 
2) 基础定义:市场分析是什么?市场分析的价值
3) 市场分析的方法 
4) 案例讲解:市场分析方法的典型场景应用 
基于产品从0到1的工作流程，本部分内容让学员
了解市场分析的基本工作方法掌握宏观经济、竞争态势、行业技术预测的分析方法掌握市场阶段和市场规模的分析方法掌握SWOT的分析方法 学习流程图工具及思维导图工具的使用借助工具进行流程和结构化思考Step03 
竞品分析 
1) 竞品分析基础定义 
2) 竞品分析前的准备工作 
3) 竞品分析的基本方法</description>
    </item>
    
    <item>
      <title>启示录 - 互联网团队构成</title>
      <link>http://azen.me/code/%E5%90%AF%E7%A4%BA%E5%BD%95---%E4%BA%92%E8%81%94%E7%BD%91%E5%9B%A2%E9%98%9F%E6%9E%84%E6%88%90/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/%E5%90%AF%E7%A4%BA%E5%BD%95---%E4%BA%92%E8%81%94%E7%BD%91%E5%9B%A2%E9%98%9F%E6%9E%84%E6%88%90/</guid>
      <description>&amp;nbsp;
产品成败的关紧因素：选择人员、界定工作职责
作者在本节中反复强调了，「不同的工作要人不同的人专职来做」
但是作为初创团队，甚至个人开发者，人力严重不足的情况下，需要「分清项目阶段」，「不同阶段让自己带上不同的思考帽」进行不掺杂无关信息的专业性思考。
通过这一章，我们可以知道，个人开发者，在整个项目流程中：
分别需要扮演什么样的角色？每种角色的职责是什么？每种角色需要分配多少精力？时间占比如何？每种角色的目标产出是什么？产品达成预期的关键点：有价值 + 可用 + 可行
关键角色及其职责角色职责补充PM 产品经理评估产品机会
机会来源：Boss拍脑袋用户反馈可用性测试产品团队和运营团队脑爆PM需要判断这些需求是否可采纳工具和方法（产出）：传统方法（产出）：市场需求文档（MRD）简化方法（产出）：机会评估（作者提出的方案）详细定义待开发产品（探索产品的解决方案）
需定义的内容：基本的产品特征和功能产品的用户体验产品的发布标准工具和方法（产出）：传统方法（产出）：产品需求文档（PRD）简化方法（产出）：简化文档（围绕产品原型展开工作）注意点：文档应该用来描述「功能」和「属性」文档不应该用来「讨论技术实现」【重要】一定要有一个全权负责「定义产品」的人
【重要】产品经理定义的产品没有价值、不具备可用性和可行性，开发团队多出色都无济于事
九成产品未能实现既定目标：
构思拙劣尚不成熟可用性差毫无价值PM最宝贵的经验：
打造优秀产品的流程领导产品团队的能力应对产品扩张的经验个人对自己的认知自我激励的能力（不是）行业知识或技术UED 用户体验设计师让真实用户测试产品
用户研究
职责：研究分析用户，评估产品或原型是否符合特定用户的使用习惯工作内容：拟订恰当的用户测试项目监督测试评估测试结果提出改进方案产出：没说...估计是用户画像之类的吧...交互设计
工作内容：理解「目标用户」的基础上：设计有价值、可用的：目标功能用户导航产品使用流程产出：「用线框绘制产品需求」，交给视觉设计师视觉设计
工作内容：根据线框，设计可见的用户界面：布局颜色字体传达并唤起产品蕴含的情感原型制作
迅速制作融合的PM、设计师创意的产品原型，让用户试用根据用户反馈意见，反复修正原型与PM密切合作，将功能和设计相结合，确保产品同时具有「可用性」和「价值」
PM → 价值UED → 可用性
为了保证「可行性」，还需要软件架构师参与评估设计和产品原型
项目经理产品定义完毕之后，开发团队接手，项目经理登场
制定计划跟踪进度目标：保证项目「按期发布」
有些项目经理，以为管理能力等同于使用微软「Project」软件的能力，这没有领悟项目管理的真谛。
优秀项目经理的特质：
给人工作紧迫感善于捕捉问题思路清晰用数据说话利用数据：识别项目方向确认项目进度改善产品和开发流程，必须从「测量、收集数据」开始务必坚持根据「数据和事实」制定决策果断判断力态度必须克服所有障碍解决所有问题一往无前、愈挫愈勇，直到项目成功RD 开发成功的产品：真实用户需求（PM） + 现阶段可行的技术方案（RD）
【tips】很多优秀的产品，是程序员抓住用户需求，自己创业研发出来的
OP 运维负责保障web服务正常运行运营对外宣传推广产品产品发布拓展市场销售渠道组织重点营销活动和PM沟通互补：
运营是产品获得需求的重要来源产品是运营获取市场营销信息的重要来源小团队的妥协方案案例让设计师身兼数职
一个创业公司只有三个人：
产品经理交互设计师（同时负责用户研究）视觉设计师（同时负责开发原型）获取了不错的结果：很快拿到产品原型（可供目标用户测试的）
「拿到产品原型」可以看做是一个里程碑可外包内容视觉设计用户研究和可用性测试外包成本较高重视「测试反馈」的话，成本更高建议让产品经理、交互设计师分担「用户研究」、「可用性测试」工作原型制作可以从开发团队借个帮手来做结果导向不要告诉别人「如何做」，而是告诉他们「做什么」
收集需求的时候，常听用户谈论「你们应该如何做」，而非「做什么」。思考解决方案是人类的天性PM如果思考「做什么」，会发现解决方案如此多客户不必考虑解决问题的途径他们不知道什么可行PM常常告诉UED如何设计产品，却忘了告诉他们「做什么」 &amp;nbsp;</description>
    </item>
    
    <item>
      <title>【Git技巧】为Git创建一个孤立分支</title>
      <link>http://azen.me/code/git%E6%8A%80%E5%B7%A7%E4%B8%BAgit%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%A4%E7%AB%8B%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/git%E6%8A%80%E5%B7%A7%E4%B8%BAgit%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%A4%E7%AB%8B%E5%88%86%E6%94%AF/</guid>
      <description>&amp;nbsp;
问题描述有时候我们需要在GIT里面创建一个空分支，该分支不继承任何提交，没有父节点，完全是一个干净的分支，例如我们需要在某个分支里存放项目文档。
使用传统的git checkout命令创建的分支是有父节点的，意味着新branch包含了历史提交，所以我们无法直接使用该命令。
可视化效果【Git技巧】为Git创建一个孤立分支  image2018-4-19_14-27-9.png&#34; data-location=&#34;Azen  【Git技巧】为Git创建一个孤立分支  image2018-4-19_14-27-9.png&#34; data-image-height=&#34;560&#34; data-image-width=&#34;1310&#34;
解决方法创建分支使用 git checkout的--orphan参数:
git checkout --orphan doc该命令会创建一个名为doc的分支，并且该分支下有前一个分支下的所有文件。
查看--orphan的帮助：
Create a new orphan branch, named &amp;lt;new_branch&amp;gt;, started from &amp;lt;start point&amp;gt; and switch to it. The first commit made on the new branch will have no parents and it will be the root of a new history totally disconnected from all the other branchs and commits.
这里的start point指的是你执行git checkout命令时的那个分支，当然新的分支不会指向任何以前的提交，就是它没有历史，如果你提交当前内容，那么这次提交就是这个分支的首次提交。</description>
    </item>
    
  </channel>
</rss>