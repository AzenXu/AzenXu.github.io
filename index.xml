<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>细胞的作战实验室</title>
    <link>http://azen.me/</link>
    <description>Recent content on 细胞的作战实验室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://azen.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>React &amp; Redux基础知识补遗</title>
      <link>http://azen.me/code/fe/react-redux-additional/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-redux-additional/</guid>
      <description>&amp;nbsp;
0x0 React基础知识部分React的定位：视图层框架当紫色的组件，希望和右边灰色的组件通信的时候，如果只有React框架：
需要把数据传到根节点，然后再分发（单向数据流）会造成大量冗余代码React把自己定位为「视图层框架」：
只负责组件的渲染数据的传递、通信之类的东东，通过其他「数据层框架」来实现State、Props、render之间的关系当组件的state或props发生改变的时候，render函数就会重新执行父组件调render，子组件也会执行render优化：子组件实现shouldComponentUpdate(nextProps, nextState)方法，通过return true/false控制是否render生命周期方法componentWillReceiveProps执行时机
组件初次挂载，不执行组件挂载后接收新Props，执行componentDidMount执行网络请求
虚拟DOM虚拟DOM是RN的基础：
虚拟DOM机制导致最终的渲染步骤非常少</description>
    </item>
    
    <item>
      <title>笔记 - 不二旅行 &amp; 创业 - 第三次大课</title>
      <link>http://azen.me/pd/ccriver-iii-unique-way/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/ccriver-iii-unique-way/</guid>
      <description>&amp;nbsp;
概述比较细分的领域，分享自己的创业经历
2012年开始做的旅行项目，如何在细分领域运用「大数据」和「人工智能」
创始人：蔡韵，先做了媒体工作，回国在央视工作做记者，希望年轻的时候更敢于去闯。美国黄石国家公园打工旅行、对旅游非常感兴趣，基于自己的兴趣而做的项目。年轻人不喜欢跟团游，DIY又太繁琐，大家都找她做旅行规划。后来发现这件事情大有可为。遇到了自己的合伙人——技术背景。在旅游行业有沉淀和经验，合伙人又有技术积淀，就一起合作了。定制游领域的标杆企业。
项目介绍目标用户：20~45岁消费人群
用户数量：30w
毛利：21%
年复购率：50%（即使是低频的旅游领域）
用户画像
问题：出境游小白对出境游有不安全感，但是不满足于传统的跟团打卡</description>
    </item>
    
    <item>
      <title>笔记 - 商业计划书 - 第三次大课</title>
      <link>http://azen.me/pd/ccriver-iii-pd/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/ccriver-iii-pd/</guid>
      <description>概述PPT
商业计划书的撰写 &amp;amp; 体会
分三部分来谈：
知识性的 - 查百度可以查到，简单罗列心法层面案例分析：商业计划书的写作 &amp;amp; 如何找投资人谈Part I：知识性商业计划书 - BP2000年，VC进入中国后才出现BP，之前最多叫「可研报告」（工程项目）</description>
    </item>
    
    <item>
      <title>笔记 - 微软加速器的创业观 - 第三次大课</title>
      <link>http://azen.me/pd/ccriver-iii-microsoft/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/ccriver-iii-microsoft/</guid>
      <description>&amp;nbsp;
概述生命的意义：发现你的天赋，把你的天赋贡献给社会。去做超越你自身以外的，成就更大的你的东西
推荐书目：千面英雄
英雄之旅的三个阶段：
(补图)
离群索居经历考验荣归故乡英雄之旅的十二步：
(补图)
普通的世界冒险召来对毛线的拒绝与智者相遇传过第一个极限测试、盟友、敌人接进深层的洞穴严酷的考验得到意义.........好莱坞大片全部符合这个结构
英雄，是把自己的生命奉献给比他更伟大事物的人
一定要找到，伴随英雄成长的导师、小伙伴</description>
    </item>
    
    <item>
      <title>2 微服务开发</title>
      <link>http://azen.me/code/micro/micro-server-iii/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/micro-server-iii/</guid>
      <description>&amp;nbsp;
0x0 微服务业务分析业务场景需求一：用户可以注册和登录
单点登录，但是需要支持跨域 - 使用其他系统的时候就不需要登录了不用session - 避免使用状态需求二：登录用户可对课程进行CURD操作
架构设计Tips：图的目的，是让我们的开发思路更清晰，开发效率更高的。所有想到的开发中应该注意到的点，都在图上标记出来就好，防止自己踩坑。不要为了作图而作图哟！
说明：</description>
    </item>
    
    <item>
      <title>3 服务编排前奏 - Docker容器化</title>
      <link>http://azen.me/code/micro/micro-server-iv/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/micro-server-iv/</guid>
      <description>&amp;nbsp;
服务Docker化
搭建Docker仓库，存image
搭建高可用的集群环境，优雅的调度程序

服务的Docker化把服务放在一个合适的运行环境里面
运行环境，又叫基础镜像
套路（Java为例）现在docker hub中寻找合适的镜像（搜Java）docker pull openjdk:7-jredocker run -it --entrypoint bash openjdk:7-jrerun个container起来把服务部署到镜像里（写DockerFile）经常变的东西不能写死到镜像里，否则一旦变更就需要重新构建这个镜像如数据库的访问地址，需要提出去而不是在配置文件里写死localhost应该写成变量的形式把要部署的服务打包成一个文件，xxx.</description>
    </item>
    
    <item>
      <title>4 服务编排 - Mesos</title>
      <link>http://azen.me/code/micro/micro-server-v/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/micro-server-v/</guid>
      <description>&amp;nbsp;
初见Program against your datacenter, like it&#39;s a single pool of resources.</description>
    </item>
    
    <item>
      <title>0 初识微服务</title>
      <link>http://azen.me/code/micro/micro-server-i/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/micro-server-i/</guid>
      <description>&amp;nbsp;
0x0 微服务导学微服务：就是普通的项目模块，运行在Docker里面，使用K8S管理Docker们
为什么要做微服务？
系统越来越复杂不同模块之间技术栈差异很大，管理复杂0x1 认识微服务软件架构的进化软件架构：在软件内部，经过综合各种因素的考量、权衡，选择特定的技术，将系统划分成不同的部分并使这些部分相互分工，彼此协作，为用户提供需要的价值。
考虑的因素业务需求（首位）已有技术栈成本组织架构（多少个小组，每个小组能做什么）可扩展性可维护性（系统的学习成本、新人上手成本、Bug修复成本）Java web的架构演进一层架构老系统：JSP - 页面、业务逻辑、数据库都放在一起MVC三层架构，纠结M到底是啥 - 其实很多概念就是用来迷惑我们的让我们纠结解决了代码调用杂乱无章的问题。通过在各层之间定义接口，让接口和维护分离，降低了维护成本dubbo背景：业务代码50w+行，产品需求不断，新人一个月上不了手，需要做拆分 - 一个大项拆成两个小项系统前端和后端服务可以从物理上管理开，变成两个可以单独维护的模块把一个单体架构变成了两个单体架构单体架构：</description>
    </item>
    
    <item>
      <title>1 微服务的着眼点及解决方案</title>
      <link>http://azen.me/code/micro/micro-service-ii/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/micro-service-ii/</guid>
      <description>&amp;nbsp;
0x0 微服务带来的问题服务之间的通讯问题？单体架构中需要通讯的情况少见，而微服务之间的相互调用非常频繁微服务如何发现彼此？单体架构使用Dubbo做服务发现：服务消费者需要对服务的提供者进行发现。发现的原理是通过KV存储有一个中间人，提供者把自己的信息告诉中间人，消费者去中间人那里拿提供者的地址微服务有各种语言，如何彼此发现？微服务怎样部署？更新？扩容？自动化流程？Jekins部署到预发环境，没问题部署到生产环境？微服务少的情况下可以这么做，但是一般很难这么做，因为需要同时上线的微服务器可能非常多，无法手动搞0x1 微服务间如何通讯通讯：socket、tcp/ip、http...
两个角度考虑通讯：
通讯模式通讯协议通讯模式角度通讯协议角度REST API特点：
请求方式描述动作类REST并不是适合于所有业务场景RPCMQ - 消息队列发布订阅的模式，可以使用MQ的方式实现</description>
    </item>
    
    <item>
      <title>9 主框架 &amp;amp; 列表页搭建</title>
      <link>http://azen.me/code/fe/react-container/</link>
      <pubDate>Wed, 17 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-container/</guid>
      <description>&amp;nbsp;
0x0 页面框架搭建基本UI元素搭建client/views/layout/app-bar.jsx
import React from &#39;react&#39; import AppBar from &#39;@material-ui/core/AppBar&#39; import ToolBar from &#39;@material-ui/core/Toolbar&#39; import Button from &#39;@material-ui/core/Button&#39; import IconButton from &#39;@material-ui/core/IconButton&#39; import HomeIcon from &#39;@material-ui/icons/Home&#39; import Typography from &#39;@material-ui/core/Typography&#39; class MainAppBar extends React.</description>
    </item>
    
    <item>
      <title>8 React业务开发 - 准备工作</title>
      <link>http://azen.me/code/fe/react-business-prepare/</link>
      <pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-business-prepare/</guid>
      <description>&amp;nbsp;
0x0 React16新特性官网：https://reactjs.org/
新特性官方说明
react+react-dom包大小：40k → 30k整个代码都用Fiber重新了error boundary捕获react渲染过程中的错误可以在正式环境中，弹个提醒告诉用户错误日志，辅助排错开发中排错new render return typesrender function中支持直接返回数组、字符串Protals：可以在组件中，把一个标签强制插入到页面任意其他标签下服务端渲染的升级 - 可以使用「流」的方式做渲染了</description>
    </item>
    
    <item>
      <title>7 React项目架构 - Router和Store的服务端渲染</title>
      <link>http://azen.me/code/fe/react-ssr-done/</link>
      <pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-ssr-done/</guid>
      <description>&amp;nbsp;
0x0 概述加入了router和store，会对服务端渲染有影响：
需要控制router的渲染，服务端渲染的内容要根据不同的url进行需要在服务端渲染中集成路由跳转功能
使用者可以从任意路由进入网站除了前端做路由跳转外，服务端也需要支持路由跳转，返回给客户端正确的页面store数据同步：服务端渲染的时候会渲染一遍，拿到html，内容扔给客户端客户端js又会渲染一次如果没拿到服务端渲染时，通过API请求到的数据，那么就需要客户端再次通过api请求，去拿数据多次api请求导致浪费需要服务端渲染时请求到的数据，让客户端直接用
0x1 store和router的服务端渲染基础配置实现
server-entry.js
修改前
import React from &#39;react&#39; import App from &#39;.</description>
    </item>
    
    <item>
      <title>6 React项目架构 - web server网络请求转发</title>
      <link>http://azen.me/code/fe/react-project-network-web-server-proxy/</link>
      <pubDate>Mon, 24 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-project-network-web-server-proxy/</guid>
      <description>&amp;nbsp;
相关commit
开发环境工程架构示意图
接口地址：https://cnodejs.org/api
accessToken问题：
部分接口需要带accessToken才有权限请求accesstoken是用户登录后，cnodejs服务器返回的accesstoken不能存在浏览器里，有安全风险解决方案：
获取accessToken后，存在web服务器里，通过session机制，在web服务端检测有木有token，没就给用户弹登录，有就转发请求实现安装工具$ npm i body-parser express-session query-string -S说明：</description>
    </item>
    
    <item>
      <title>5 React项目架构 - Store</title>
      <link>http://azen.me/code/fe/react-project-store/</link>
      <pubDate>Sun, 23 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-project-store/</guid>
      <description>&amp;nbsp;
相关commit
什么是Storestore - 数据流解决方案
mvc模式在前端并不特别适用：很多数据都是异步的页面之间共享一部分数据，数据更新的时候需要让view层检测到数据的更新否则会导致view层和model层脱节，渲染出错store：「flux单向数据流模式」中，整个app有个单独存放数据的地方，叫store页面上的所有内容都是根据store上的内容渲染出来的store里的任何数据的变化，都会影响到view的渲染效果store决定了页面展示成什么样子解决mvc中数据维护问题，把数据维护集中在一个地方只要使用action处理数据，view就能自动更新react：是一个视图层解决方案它的虚拟dom特性，让我们即便把整个数据对象都彻底更新了（换了个数据树object），react也能高效处理视图重新渲染过程虚拟dom的出现，让这种单一数据流模式得以实现Mobx - 一种flux模式下，数据流解决方案的后起之秀
文档安装：`npm i mobx mobx-react -S`它的所有数据一旦更改，绑定数据的地方会立刻更新使用方法比Redux简单很多Redux涉及Action、Dispatcher、Reducer、Store，概念比较多，学习成本较高数据一旦更新，需要做整棵数据树的全拷贝，生成一棵新树，浪费资源每发一个action都会产生一个新对象新对象的到来，会触发所有Component的重新渲染由于虚拟dom，这种重新渲染成本不高，所以可以这么做，效率高vue没有虚拟dom机制，所以无法这么做Mobx声明Store的时候，声明其为Observable就好值改变会自动通知对应view，触发该view刷新整个数据都只有一份，不会生成新的一个对象只不过它有数据变动，会通知对应的view执行效率高一些，不需要每次都拷贝一个新的数据树</description>
    </item>
    
    <item>
      <title>4 React项目架构 - 目录划分 &amp;amp; Router配置</title>
      <link>http://azen.me/code/fe/react-project-router-config/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-project-router-config/</guid>
      <description>&amp;nbsp;
相关commit
0x0 目录划分目录划分介绍views文件夹
存放项目功能模块App.jsx需要根据路由配置，分割子级目录如列表页：index.jsx为这个页面的出口，向外抛出去列表每一项都会建一个组件如：titlebar会建一个组件这些东西会放入同一个文件夹里，因为属于同一个页面嘛config文件夹
放app的配置 &amp;amp; 第三方类库的引用router.jsx 路由的配置、映射和跳转等store文件夹
存放数据管理的文件夹（包括数据的获取和封装）如用户登录的信息全局类信息需要存起来，就存在store中的某个地方是web app单页应用开发新增的功能需要单独拿出来components</description>
    </item>
    
    <item>
      <title>3 React前端工程架构 - eslint &amp;amp; 其他优化</title>
      <link>http://azen.me/code/fe/react-ssr-optimize/</link>
      <pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-ssr-optimize/</guid>
      <description>&amp;nbsp;
相关commit
安装eslint：`npm i eslint -D`
创建eslint配置文件/.eslintrc
{ &#34;extends&#34;: &#34;standard&#34; }</description>
    </item>
    
    <item>
      <title>2 React前端工程架构 - 开发环境实时更新</title>
      <link>http://azen.me/code/fe/react-ssr-dev-hotload/</link>
      <pubDate>Wed, 19 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-ssr-dev-hotload/</guid>
      <description>&amp;nbsp;
dev server &amp;amp; hot load相关commit
相关commit
解决hot load缓慢的commit
服务端实时渲染相关commit</description>
    </item>
    
    <item>
      <title>0 前端项目技术选型</title>
      <link>http://azen.me/code/fe/fe-arch-overview/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/fe-arch-overview/</guid>
      <description>&amp;nbsp;
0x0 单页应用 &amp;amp; 多页应用 相关技术选型不同项目需求不同：
传统的多页网站不会用React单页应用用jQuery实现困难，需要自己处理技术细节，出错的可能性多两大类站点多页应用每个新页面都需要做页面的跳转，是通过浏览器发请求到服务端的
日常：前端拿到设计图做好模板，后端用jsp等模板引擎填充数据，拼html代码，形成真实的html给浏览器做显示
特点：
每个页面跳转都经过服务端新页面出现需要刷新浏览器用户需要有一定的等待时间js定位：js主要做动画，数据处理都是在后端做好的</description>
    </item>
    
    <item>
      <title>1 React前端工程架构 - 基本配置</title>
      <link>http://azen.me/code/fe/react-ssr-config/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/fe/react-ssr-config/</guid>
      <description>&amp;nbsp;
0x0 概述上一篇文章我们聊过，工程架构的目标，主要是保证「开发效率」的。包括：
解放生产力环境搭建质量保障本篇文章，将会就React的实际配置做下做下初步说明
内容包括：
npm、webpack、babel编译打包基础配置SSR（服务端渲染）基础配置dev server实现代码实时编译hot module实现代码热更新服务端渲染的实时更新eslint保证代码质量0x1 编译打包基础配置本节commit
webpackwebpack是一个模块打包器，核心是他的loader</description>
    </item>
    
    <item>
      <title>Lean Startup II 定义两个假设</title>
      <link>http://azen.me/pd/lean-startup-guess/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/lean-startup-guess/</guid>
      <description>&amp;nbsp;
时机：用户探索阶段
定义用户痛点假设：
观察用户痛点大小决定了商业模式的空间观察用户痛点持续性决定了商业模式的持续性痛点本身会不断演化痛点具有时效性定义解决方案假设：
解决方案和用户痛点的「匹配度」能不能解决这个痛点解决方案和用户痛点的「吻合度」
产品和市场之间的吻合度0x0 用户痛点是什么Guy Kawasaki：思考不如意的事情，然后从这些点切入，寻找新的机会
SnapchatSituation痛点一：社交压力 传统社交媒体分享自己照片时的「点赞压力」「期望得到评论压力」</description>
    </item>
    
    <item>
      <title>Lean Startup III 用MVP验证两个假设</title>
      <link>http://azen.me/pd/lean-startup-verify/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/lean-startup-verify/</guid>
      <description>&amp;nbsp;
重点：
验证解决方案和痛点的匹配度通过不断迭代，实现对真实用户的痛点、有效解决方案的不断逼近工具：Minimum Viable Product
最小可行产品针对天使用户的「最小功能组合」关键点：只针对天使用户对产品容忍度高能看到产品的未来愿意互动，一起改进产品最小、最基本功能组合建议把想象中的产品砍成两半，再砍两半关键点：以最快的速度通过MVP获取认知，放弃一切无助于认知的功能
速度聚焦
举例：Zappos - 美国最大的鞋类电商网站待验证：有没有人愿意通过网购买鞋</description>
    </item>
    
    <item>
      <title>Lean Startup 概述</title>
      <link>http://azen.me/pd/lean-startup-one/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/lean-startup-one/</guid>
      <description>&amp;nbsp;
0x0 新思维运动三个代表Steve Blank
《四步创业法》《创业者手册》Eric Rise
Steve Blank的学生《精益创业》Reid Hoffman
LinkedIn创始人核心 - 承认未知从「天才人物的天才设想、完美计划和完美执行」 → 「科学试错、民主创业」</description>
    </item>
    
    <item>
      <title>区块链基础 &amp;amp; 公链原理</title>
      <link>http://azen.me/code/block-chain-i/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/block-chain-i/</guid>
      <description>&amp;nbsp;
0x0 区块链相关概念法币：日常生活中用到的纸币
去中心化：比特币不需要中间机构做货币的发行工作 - 货币是被「发现」的，而不是「发明」的。需要注意的是，并不是所有的区块链项目都是去中心化的
挖矿：「结点A」希望给「结点B」转钱，需要「矿工」帮A把钱「搬运」过去
这种搬运的行为就是「挖矿」挖矿的平均时长：10分钟（转钱不是实时到账的）广播：矿工除了能「挖矿」，还可以「广播」 - 每挖成功一次矿，就会给所有结「广播」一次</description>
    </item>
    
    <item>
      <title>探索互联网产品的最佳实践</title>
      <link>http://azen.me/pd/product-create-path/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/product-create-path/</guid>
      <description>&amp;nbsp;
根据《启示录》第二部分 - 流程 相关内容，重新梳理总结而成。省略了部分「大公司」相关内容 &amp;amp; 「开发」相关内容
0x0 概述产品探索 + 产品开发 = 完整产品</description>
    </item>
    
    <item>
      <title>Golang与密码学</title>
      <link>http://azen.me/code/golang-and-security/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/golang-and-security/</guid>
      <description>&amp;nbsp;
0x0 概述这篇文档主要聊聊三种加密方式与Golang实现
哈希加密对称加密非对称加密0x1 哈希加密哈希算法我们知道，查找中，有「哈希查找」，是一种比「顺序查找」更快的查找方法。
「哈希查找」的关键点，就是实现一种「哈希算法」，使得每个任意key，经过哈希算法计算后，可以获得一个定长的散列值。
相同key经过相同哈希算法散列之后，获得相同的散列值不同key经过相同哈西算法散列之后，获得不同的散列值特点：
可以把任意长度的「明文」，散列成固定长度的「指纹」正向计算简单快速，逆向推算困难，基本不可能逆推出明文明文有一点点变化，密文就会改变优秀的散列算法需要尽量避免两个不同的明文，加密出来是相同的指纹发展：
 取模操作 → 异或运算→ 位移操作</description>
    </item>
    
    <item>
      <title>启示录 - 互联网团队构成</title>
      <link>http://azen.me/pd/product-create-team/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/pd/product-create-team/</guid>
      <description>&amp;nbsp;
产品成败的关紧因素：选择人员、界定工作职责
作者在本节中反复强调了，「不同的工作要人不同的人专职来做」
但是作为初创团队，甚至个人开发者，人力严重不足的情况下，需要「分清项目阶段」，「不同阶段让自己带上不同的思考帽」进行不掺杂无关信息的专业性思考。
通过这一章，我们可以知道，个人开发者，在整个项目流程中：
分别需要扮演什么样的角色？每种角色的职责是什么？每种角色需要分配多少精力？时间占比如何？每种角色的目标产出是什么？产品达成预期的关键点：有价值 + 可用 + 可行</description>
    </item>
    
    <item>
      <title>Linux定时任务</title>
      <link>http://azen.me/code/linux-timer/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/linux-timer/</guid>
      <description>&amp;nbsp;
参考资料：鸟哥的linux私房菜
Linux 排程就是透過 crontab 與 at 這兩個東西
at 和 crontabat：处理只发生一次的事件</description>
    </item>
    
    <item>
      <title>3 网站上云</title>
      <link>http://azen.me/code/micro/golang-server-vii/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-vii/</guid>
      <description>&amp;nbsp;
0x0 CloudNative概述是什么：借助于大规模分布式系统在资源利用上的灵活使用、服务化拆分，演变出来的一种软件部署、架构、上线的流程方面的最佳实践
Cloud Native在云刚出来的时候就有了没有任何组织清晰定义云原生，而是一种习惯用法和最佳实践参考：百度百科
特点松耦合(SOA)每一个独立拆分的服务，具有独立完整的生命周期，不受别的服务影响和制约。
微服务领域，涉及其他知识点：服务注册微服务网关契约调用等以防止每一个服务调用之间出现不一致不统一的情况项目实现无状态(Stateless)RESTful中提到过，参考
伸缩性(scalability)伸缩性分为：纵向的伸缩(scale up)、横向的伸缩(scale out)</description>
    </item>
    
    <item>
      <title>2-x 复习 &amp;amp; 完善Comments功能模块</title>
      <link>http://azen.me/code/micro/golang-server-vi/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-vi/</guid>
      <description>&amp;nbsp;
这一节笔记，写于学习完课程 &amp;amp; 妈来北京玩了10天之后。
通过完善这个模块，可以快速回顾学到的服务端开发知识点。以后如果忘了，也可以循着这章再走一遍，就可以想起来了~
开始标签：https://github.com/AzenXu/Go-execise/tree/2018.8.21.comment.start
结束标签：https://github.com/AzenXu/Go-execise/tree/2018.8.21.comment.done

思路：
以前端为调试开始点。</description>
    </item>
    
    <item>
      <title>2-5 前端页面</title>
      <link>http://azen.me/code/micro/golang-server-v/</link>
      <pubDate>Thu, 05 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-v/</guid>
      <description>&amp;nbsp;
前端部分，展示了如何串联三个服务器方面的知识，所以还是很有必要好好看下的。所以写了这篇wiki。
想知道前端应该如何使用cookie和session把身份验证流程打通？
ajax如何和服务端进行交互？
前端 → 代理服务器 → 业务服务器 的完整链条是怎样的？</description>
    </item>
    
    <item>
      <title>2-4 前端服务</title>
      <link>http://azen.me/code/micro/golang-server-iv/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-iv/</guid>
      <description>&amp;nbsp;
概述前端服务（大前端）：
前台的HTML+CSS+JS后端的Go的WebServer小的网站：
直接一个webServer把结果返回给前端完事儿弊端：
没法解耦效率低能承载的业务量有限扩容非常复杂没办法进行分布式拆分和服务化解耦
前端服务 (不是前台)：
→ 前台（Front in 的 UI）</description>
    </item>
    
    <item>
      <title>2-3 Scheduler模块</title>
      <link>http://azen.me/code/micro/golang-server-iii/</link>
      <pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-iii/</guid>
      <description>&amp;nbsp;
概念Scheduler:调度器
作用：处理延时型任务（不能马上给结果的）（异步任务、周期性任务、瞬时可能并不会有结果的任务）
原理：延时任务们分发到scheduler，scheduler根据timer的interval等属性，进行定时触发
说明：异步任务才需要Scheduler
为什么需要scheduler我们项目中有异步任务 - 延时删除视频
我们在删除数据的时候，一般先在source deletesource delete 用户看不到，但是其实是存在的。会把这个任务下发下去，在scheduler中过一周或一个月，才真正删除。那么这个schedler会每隔一个月运行一次。Scheduler Server包含什么ServerScheduler是一个独立的服务接收任务用的Timer定时触发任务的Task Runner (生产者/消费者模型下)描述timer每次触发的时候，下面的任务该怎么做很多中情况，任务分为两种：读取任务执行任务代码结构/scheduler</description>
    </item>
    
    <item>
      <title>2-2 Stream模块</title>
      <link>http://azen.me/code/micro/golang-server-ii/</link>
      <pubDate>Mon, 02 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-ii/</guid>
      <description>&amp;nbsp;
Stream Server两个关键知识点
Upload filesToken bucket - 限流特点静态视频，非RTMP
RTMP：用在直播上的，Client端不断有Input，别的Client端不断有Output。复杂度比较高
Streaming部分：</description>
    </item>
    
    <item>
      <title>2-1 流媒体 - API模块</title>
      <link>http://azen.me/code/micro/golang-server-i/</link>
      <pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/micro/golang-server-i/</guid>
      <description>&amp;nbsp;
0x0 基础概念API是什么后端对外形成Service的接口
REST是一种设计风格，不是任何架构标准RESTful API通常使用HTTP作为通信协议，JSON作数据格式RESTful API特点统一接口无状态无论什么时候调用，返回的都是我想要的东西API这个Service这个节点不具备状态可缓存分层（Layerd System）API的service可以分过好多层，每一层负责其中一部分功能CS模式REST设计原则以URL（统一资源定位符）风格设计API 资源路径类似本地文件系统风格通过不同的method区分对资源的CURDgetpostputdelete返回码（Status Code）需要符合HTTP资源描述的规定0x1 API模块设计 (RESTful风格)分析实体及关系三个实体用户资源用户上传的视频视频下面的评论用户和资源发生的互动实体间的关系资源属于用户评论属于资源</description>
    </item>
    
    <item>
      <title>Go 语言狂人许式伟：编程的意义就是让世界变得有趣一些</title>
      <link>http://azen.me/code/qiniu-xushiwei/</link>
      <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/qiniu-xushiwei/</guid>
      <description>&amp;nbsp;
从小孩的教育到世界观当小孩长大以后，未来十年二十年的时候整个社会是什么样子的？
只有明白了那个时候的世界是什么样的，才能想象教会小孩什么东东可以让他适应那个时候的世界——这个和做企业是一样的
不要因为别人的言论而认为世界是什么样的，应该有自己的世界观
职业生涯工作六年以后，有困惑：为什么我们做的wps不赚钱呢？做什么业务才是符合互联网时代的？商业上才能成功的？07年坚决转型产品经理，只有PM才能在商业上探讨产品成功的可能性。07思考：移动互联网的大趋势下，什么东西会变化？发现：似乎还没有移动互联网下的存储公司创建七牛七牛的使命：释放社会的创造力。
解释：你有没有在做一个新的，以前人没有试过的探索。这件事是勇敢的、值的鼓励的。你起码试了，别人连试都不敢试。云计算可以降低试错成本，让你可以一个月、一周就能判断你的尝试是不是一个靠谱的事情。
几个观点如果把人看成一个投资人的话，投资企业和思考小孩的教育有共同点：你要思考未来。写代码不习惯单步调试：人需要在把自己逼到资源相对匮乏下，才能更有效的突破（这个观点和辉哥的观点相同，想要高效学习，需要认为制造时间上的稀缺性）编程的意义在于，让你真正能够创造一个世界，或者说改变一个世界。人的意义在于自我实现，自己追求的是什么，就去实现什么。所以，要让这个世界变的更有趣一些。视频内容&amp;lt;iframe src=&#34;//player.bilibili.com/player.html?aid=12069987&amp;amp;cid=19912250&amp;amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;</description>
    </item>
    
    <item>
      <title>逆向记录：墨墨</title>
      <link>http://azen.me/code/crack/ios-crack-xiii/</link>
      <pubDate>Sun, 13 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-xiii/</guid>
      <description>&amp;nbsp;
问题免费的单词数量有上限，超过需要付费。
嗯！只要能把这个付费功能干掉，从明天起一定好好背单词...
开始猜想每次添加新单词，或者更改最大单词数的时候，墨墨会从服务端拉当前用户最大单词数的数据。
之后，存到某个单例里面，然后持久化到本地（证据：断网依然有最大单词限制，添加新单词依然提示购买）
思路先从VC的方法中找线索，没有的话，尝试找找有木有xxxManager之类的类
开始收集信息3524 ?? 0:02.20 /var/containers/Bundle/Application/4FC3FD5F-AF17-41C2-8279-C65437176F14/momo_ios.app/momo_ios</description>
    </item>
    
    <item>
      <title>7逆向 - 动态调试</title>
      <link>http://azen.me/code/crack/ios-crack-xii/</link>
      <pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-xii/</guid>
      <description>&amp;nbsp;
概念→ 把程序运行起来，通过打断点、打印等方式，查看参数、返回值、函数的调用流程
→ 可以进入函数，一步一步的看看函数的调用是什么样的
→ 逆向的过程中也经常要这么干..
→ 比如，我们已经知道抢红包的方法是哪个方法了，那最好可以在那个方法里打一个断点，调试下参数、函数之间的调用关系等
调试原理Xcode的调试器：LLDB</description>
    </item>
    
    <item>
      <title>6Tweak - 批量hook函数添加log - logify.pl</title>
      <link>http://azen.me/code/crack/ios-crack-xi/</link>
      <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-xi/</guid>
      <description>&amp;nbsp;
希望追踪用户点击某个按钮之后的调用逻辑
如：微信点击红包之后，进行抢红包，想知道点击之后和哪个方法有关？
小例子希望找到微信点击红包之后，进行了哪些操作
猜测应该是调用了当前VC的某个方法，实现了抢红包操作的
首先找到所在VCClass-dump出来头文件找到我们找的头文件BaseMsgControllerViewController
但是方法很多，我们怎么知道需要调用的是哪个方法呢？
找到我们需要的相关方法方案一：Hook所有方法把它所有的方法都hook一遍，打印一下，就可以追踪每一个方法了。观察分析控制台的log，就知道了。
问题：麻烦！:如果需要打印参数更麻烦: 如果函数有返回值，还希望打印下返回值...</description>
    </item>
    
    <item>
      <title>5Tweak - 可用的辅助小语法(Logos语法)</title>
      <link>http://azen.me/code/crack/ios-crack-x/</link>
      <pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-x/</guid>
      <description>&amp;nbsp;
Weak里%有关的语法
%ctor &amp;amp; %dtorctor：加载动态库的时候调用，做初始化操作
dtor：收尾的操作
%new在方法前加 %new，说明是一个新定义的方法
如果这样写了make package的时候还是找不到，可以用@interface .</description>
    </item>
    
    <item>
      <title>4Tweak - 多文件开发</title>
      <link>http://azen.me/code/crack/ios-crack-ix/</link>
      <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-ix/</guid>
      <description>&amp;nbsp;
文件类型实际上，用.m文件也可以
多文件开发举例使用OC文件的使用举例
1.直接importOC文件 - 如果有文件夹需要写明文件夹 &amp;quot;Model/MJPerson.h&amp;quot;
2.变更了Tweak.xm的文件层级嘛(放到src下了)，需要更新下Makefile文件的配置说明
3.告诉theo 我们自定义的.m文件也要参与编译</description>
    </item>
    
    <item>
      <title>3Teak - 原理</title>
      <link>http://azen.me/code/crack/ios-crack-viii/</link>
      <pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-viii/</guid>
      <description>&amp;nbsp;
基本流程编写代码make编译 theos中出现了一个动态库，说明make操作，把编写的代码生成了一个动态库。
make package把动态库打包成了一个deb文件
make package：这个指令，是包含了make中的「编译」功能的，所以以后不用make，直接make package就好
make install远程登录手机(根据环境变量)传递deb包数据Cydia安装deb包Cydia把里面的动态库拿出来plist文件：里面存了靶App的Bundle ID 放到这里这个东东提供了安装机制影响靶App点击靶App的时候，Cydia Substrate会看文件夹下的plist文件写的bundle ID，一旦发现bundle ID匹配，就会把动态库载入内存，对靶App的内存代码(二进制代码)进行修改。</description>
    </item>
    
    <item>
      <title>2Tweak - 很小的小练习</title>
      <link>http://azen.me/code/crack/ios-crack-vii/</link>
      <pubDate>Mon, 07 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-vii/</guid>
      <description>&amp;nbsp;
去掉SpringBoard的未读数字思路编写一个Tweak给桌面用桌面应用：SpringBoard路径：System/Library/CoreServices/SpringBoard.app找到Mach-O文件验证是否加壳 otool -l SpringBoard | grep cryptMachOView查看是否加密class-dump出头文件希望查看下通知个数这个UI控件在哪里..但是没有办法用Reveal查通过Cycript查看控件在哪使用Cycript寻找待修元素在哪里查看根控制器的子控制器找根控制器的Subviews - 希望找到小红点UI问题：查到的东西过多</description>
    </item>
    
    <item>
      <title>1TweakStartUp - 喜马拉雅FM去广告</title>
      <link>http://azen.me/code/crack/ios-crack-vi/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-vi/</guid>
      <description>&amp;nbsp;
思路Reveal查看广告控件处理方案一：用cycript把这个控件干掉问题：不彻底，只是在内存中干掉了方案二：把这个View的init方法的实现hook掉，直接return nil;通过class-dump找到这个View的头文件hook的简单实现Theos工具作用：实现比较简单的hook操作
使用原理编写的hook代码 → deb插件 → 安装到手机上 → 修改宿主函数</description>
    </item>
    
    <item>
      <title>5逆向 - 脱壳(Qiao)</title>
      <link>http://azen.me/code/crack/ios-crack-v/</link>
      <pubDate>Sat, 05 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-v/</guid>
      <description>&amp;nbsp;
e问题：要分析一个安装到手机上的应用，需要找到手机上的ipa包
找到iPhone上的安装包ps -A 枚举所有手机上的进程此处就是安装包的位置把安装包拿到macclass-dump、Hopper的时候，无法对改ipa包进行解析说明ipa被加密了加壳开发完一个app之后，打包成了ipa文件 → 上传到App Store(app store对ipa进行加壳操作 - 加密)</description>
    </item>
    
    <item>
      <title>4逆向 - Mach-O</title>
      <link>http://azen.me/code/crack/ios-crack-iv/</link>
      <pubDate>Fri, 04 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-iv/</guid>
      <description>&amp;nbsp;
App从开发到安装到手机的过程开发完毕 → 编译、链接、签名 → .app包
app包的内容
图片、bundle、nib、Mach-O文件(写的代码编译成了这个文件，就是iOS的可执行文件)
→ 压缩(改后缀，变成ipa文件)</description>
    </item>
    
    <item>
      <title>3逆向 - Reveal</title>
      <link>http://azen.me/code/crack/ios-crack-iii/</link>
      <pubDate>Thu, 03 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-iii/</guid>
      <description>&amp;nbsp;
下载：https://revealapp.com/download/
Crack版：https://juejin.im/post/5a31cdabf265da43133d276b
这个东东只能识别UI结构，可以结合Cycript分析控制器结构
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>2逆向 - Cycript</title>
      <link>http://azen.me/code/crack/ios-crack-ii/</link>
      <pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-ii/</guid>
      <description>&amp;nbsp;
想知道当前运行的App的布局、实例方法、都是啥
想动态给当前App增加一些羞羞的东东？
...
嗯呐，就是这一节，你来对了！
概述文档：Cycript
是Objective-C++、ES6、Java等语法的混合物
用途：探索、修改、调试正在运行的mac/iOS App
安装：Cydia安装</description>
    </item>
    
    <item>
      <title>1逆向 - 环境准备</title>
      <link>http://azen.me/code/crack/ios-crack-i/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/crack/ios-crack-i/</guid>
      <description>&amp;nbsp;
Cydia越狱之后的苹果商店
作者：Jay Freeman - 免费版周杰伦...(阿婆主ID: saurik)
上一张照片膜拜下...越狱开发的领袖人物
Cydia上软件的作者是他的，都可以放心食用~
Cydia安装东西一般是用来安装插件和主题的，安装的软件格式是deb格式</description>
    </item>
    
    <item>
      <title>【Git技巧】为Git创建一个孤立分支</title>
      <link>http://azen.me/code/git-branch/</link>
      <pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://azen.me/code/git-branch/</guid>
      <description>&amp;nbsp;
问题描述有时候我们需要在GIT里面创建一个空分支，该分支不继承任何提交，没有父节点，完全是一个干净的分支，例如我们需要在某个分支里存放项目文档。
使用传统的git checkout命令创建的分支是有父节点的，意味着新branch包含了历史提交，所以我们无法直接使用该命令。
可视化效果【Git技巧】为Git创建一个孤立分支  image2018-4-19_14-27-9.png&#34; data-location=&#34;Azen  【Git技巧】为Git创建一个孤立分支  image2018-4-19_14-27-9.</description>
    </item>
    
  </channel>
</rss>